#!/usr/bin/env node
import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';
import { execFileSync } from 'child_process';
// ============================================================================
// Templates
// ============================================================================
// ASCII art logo based on eyeglass.svg - glasses with cursor pointer in right lens
// SVG has: two round lenses, short vertical bridge, temples angling up-outward, pointer in right lens
const LOGO = `
\x1b[36m  ╱                             ╲
   ╲ ╭───────╮     ╭───────╮ ╱
     │       │     │  \x1b[34m▲\x1b[36m    │
     │       │  │  │  \x1b[34m█▸\x1b[36m   │
     ╰───────╯     ╰───────╯\x1b[0m
          \x1b[1meyeglass\x1b[0m
`;
const NEXT_CONFIG_ADDITION = `
// Eyeglass configuration - Auto-generated by eyeglass init
const withEyeglass = (nextConfig) => {
  if (process.env.NODE_ENV === 'production') return nextConfig;
  return {
    ...nextConfig,
    webpack: (config, options) => {
      if (!options.isServer) {
        config.module.rules.push({
          test: /node_modules\\/@eyeglass\\/inspector/,
          sideEffects: true,
        });
      }
      if (typeof nextConfig.webpack === 'function') {
        return nextConfig.webpack(config, options);
      }
      return config;
    },
  };
};
`;
const MCP_STDIO_CONFIG = {
    command: 'npx',
    args: ['eyeglass-bridge'],
};
const CLAUDE_CONFIG = {
    mcpServers: {
        eyeglass: MCP_STDIO_CONFIG,
    },
};
// GitHub Copilot CLI agent config format (.copilot/mcp-config.json)
const COPILOT_MCP_CONFIG = {
    mcpServers: {
        eyeglass: {
            type: 'local',
            command: 'npx',
            args: ['eyeglass-bridge'],
            tools: ['*'],
        },
    },
};
// Codex CLI uses HTTP endpoints, so we just provide instructions
const CODEX_BASE_URL = 'http://localhost:3300/api';
const EYEGLASS_SKILL = `---
name: eyeglass
description: Listen for Eyeglass requests from the browser and make UI changes
user_invocable: true
---

# Eyeglass Skill

Eyeglass lets users select UI elements in their browser and request changes. When invoked, enter a listening loop to handle requests.

## How It Works

1. User selects an element in their browser using the Eyeglass inspector
2. User types a request (e.g., "make this blue", "add a button here")
3. You receive the element context and make the requested changes
4. User can send follow-up requests on the same element

## Listening Loop

When this skill is invoked, enter a continuous listening mode:

\`\`\`
while listening:
  1. Call wait_for_request() - blocks until user selects an element
  2. Call update_status("fixing", "Working on it...") to show progress
  3. Use report_action() to show what files you're reading/writing
  4. Make the requested code changes
  5. Call update_status("success", "Done!") when complete
  6. IMMEDIATELY call wait_for_request() again to continue listening
\`\`\`

## Available MCP Tools

- **wait_for_request()** - Block until user selects an element. Returns element context.
- **update_status(status, message)** - Update the browser UI. Status: "fixing" | "success" | "failed"
- **report_action(action, target)** - Show progress. Action: "reading" | "writing" | "searching"
- **send_thought(content)** - Share your reasoning with the user
- **ask_question(question, options)** - Ask the user a multiple choice question

## Example Flow

\`\`\`
User invokes: /eyeglass

You: [Call wait_for_request()]
     → Returns: User selected <Button /> and said "make this red"

You: [Call update_status("fixing", "Adding red variant to Button...")]
     [Call report_action("reading", "src/components/Button.tsx")]
     [Read the file, make changes]
     [Call report_action("writing", "src/components/Button.tsx")]
     [Write the changes]
     [Call update_status("success", "Button is now red!")]

You: [Call wait_for_request()] ← IMPORTANT: Go back to listening!
     → Waiting for next request...
\`\`\`

## Key Points

- **Always loop back** - After completing a request, immediately call wait_for_request() again
- **Show progress** - Use update_status and report_action so the user sees what you're doing
- **Stay in the browser** - The user doesn't need to come back to the terminal
- **Handle follow-ups** - Users can send multiple requests on the same element
`;
// ============================================================================
// Utilities
// ============================================================================
function log(message, type = 'info') {
    const prefix = {
        info: '\x1b[36m→\x1b[0m',
        success: '\x1b[32m✓\x1b[0m',
        warn: '\x1b[33m⚠\x1b[0m',
        error: '\x1b[31m✗\x1b[0m',
    };
    console.log(`${prefix[type]} ${message}`);
}
function fileExists(filePath) {
    return fs.existsSync(filePath);
}
function readFile(filePath) {
    return fs.readFileSync(filePath, 'utf-8');
}
function writeFile(filePath, content) {
    fs.writeFileSync(filePath, content, 'utf-8');
}
async function promptAgentSelection() {
    const agents = [
        { key: '1', name: 'Claude Code', type: 'claude', selected: false },
        { key: '2', name: 'GitHub Copilot CLI', type: 'copilot', selected: false },
        { key: '3', name: 'OpenAI Codex CLI', type: 'codex', selected: false },
    ];
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    const question = (prompt) => {
        return new Promise((resolve) => {
            rl.question(prompt, resolve);
        });
    };
    console.log('\n\x1b[1mSelect coding agents to configure:\x1b[0m');
    console.log('\x1b[2m(Enter numbers separated by spaces, or "a" for all)\x1b[0m\n');
    for (const agent of agents) {
        console.log(`  ${agent.key}) ${agent.name}`);
    }
    console.log('');
    const answer = await question('\x1b[36m>\x1b[0m ');
    rl.close();
    const input = answer.trim().toLowerCase();
    if (input === 'a' || input === 'all') {
        return agents.map((a) => a.type);
    }
    const selected = [];
    const parts = input.split(/[\s,]+/);
    for (const part of parts) {
        const agent = agents.find((a) => a.key === part);
        if (agent && !selected.includes(agent.type)) {
            selected.push(agent.type);
        }
    }
    // Default to Claude if nothing selected
    if (selected.length === 0) {
        log('No selection made, defaulting to Claude Code', 'warn');
        return ['claude'];
    }
    return selected;
}
function detectPackageManager() {
    const cwd = process.cwd();
    if (fileExists(path.join(cwd, 'bun.lockb')))
        return 'bun';
    if (fileExists(path.join(cwd, 'pnpm-lock.yaml')))
        return 'pnpm';
    if (fileExists(path.join(cwd, 'yarn.lock')))
        return 'yarn';
    return 'npm';
}
function installPackage(packageName, dev = true) {
    const pm = detectPackageManager();
    const devFlag = {
        npm: dev ? '--save-dev' : '--save',
        yarn: dev ? '--dev' : '',
        pnpm: dev ? '--save-dev' : '',
        bun: dev ? '--dev' : '',
    };
    const installCmd = {
        npm: 'install',
        yarn: 'add',
        pnpm: 'add',
        bun: 'add',
    };
    log(`Installing ${packageName} with ${pm}...`);
    try {
        const args = [installCmd[pm], packageName];
        if (devFlag[pm]) {
            args.push(devFlag[pm]);
        }
        execFileSync(pm, args, { stdio: 'pipe', cwd: process.cwd() });
        return true;
    }
    catch (error) {
        return false;
    }
}
function detectProject() {
    const cwd = process.cwd();
    const hasTs = fileExists(path.join(cwd, 'tsconfig.json'));
    // Vite
    const viteConfigTs = path.join(cwd, 'vite.config.ts');
    const viteConfigJs = path.join(cwd, 'vite.config.js');
    if (fileExists(viteConfigTs)) {
        return { type: 'vite', configFile: viteConfigTs, typescript: true };
    }
    if (fileExists(viteConfigJs)) {
        return { type: 'vite', configFile: viteConfigJs, typescript: hasTs };
    }
    // Next.js
    const nextConfigs = ['next.config.ts', 'next.config.mjs', 'next.config.js'];
    for (const config of nextConfigs) {
        const configPath = path.join(cwd, config);
        if (fileExists(configPath)) {
            return { type: 'next', configFile: configPath, typescript: hasTs };
        }
    }
    // Remix
    const remixConfig = path.join(cwd, 'remix.config.js');
    if (fileExists(remixConfig)) {
        return { type: 'remix', configFile: remixConfig, typescript: hasTs };
    }
    // CRA
    const pkgPath = path.join(cwd, 'package.json');
    if (fileExists(pkgPath)) {
        const pkg = JSON.parse(readFile(pkgPath));
        if (pkg.dependencies?.['react-scripts']) {
            // Find entry file
            const entryFiles = ['src/index.tsx', 'src/index.ts', 'src/index.jsx', 'src/index.js'];
            for (const entry of entryFiles) {
                if (fileExists(path.join(cwd, entry))) {
                    return { type: 'cra', entryFile: path.join(cwd, entry), typescript: hasTs };
                }
            }
            return { type: 'cra', typescript: hasTs };
        }
    }
    return { type: 'unknown', typescript: hasTs };
}
// ============================================================================
// HTML Entry Point Detection
// ============================================================================
/**
 * Parses index.html to find the entry script path.
 * Looks for <script type="module" src="..."> tags and returns the first match.
 * Works for vanilla Vite, React, Vue, and other projects that use index.html.
 */
function findEntryFromHtml(cwd) {
    // Common locations for index.html
    const htmlFiles = [
        'index.html',
        'public/index.html',
        'src/index.html',
    ];
    for (const htmlFile of htmlFiles) {
        const htmlPath = path.join(cwd, htmlFile);
        if (!fileExists(htmlPath))
            continue;
        const content = readFile(htmlPath);
        // Match <script type="module" src="..."> - handles various quote styles and spacing
        // This regex captures the src attribute value from module scripts
        const moduleScriptRegex = /<script[^>]*type\s*=\s*["']module["'][^>]*src\s*=\s*["']([^"']+)["'][^>]*>/gi;
        const altModuleScriptRegex = /<script[^>]*src\s*=\s*["']([^"']+)["'][^>]*type\s*=\s*["']module["'][^>]*>/gi;
        let match = moduleScriptRegex.exec(content) || altModuleScriptRegex.exec(content);
        if (match && match[1]) {
            let scriptSrc = match[1];
            // Remove leading slash if present (Vite uses /src/main.js format)
            if (scriptSrc.startsWith('/')) {
                scriptSrc = scriptSrc.slice(1);
            }
            // Resolve the path relative to the project root
            const scriptPath = path.join(cwd, scriptSrc);
            if (fileExists(scriptPath)) {
                return scriptPath;
            }
        }
    }
    return null;
}
// ============================================================================
// Config Modifiers
// ============================================================================
function setupEyeglassSkill(dryRun) {
    const cwd = process.cwd();
    const skillsDir = path.join(cwd, '.claude', 'skills');
    const skillPath = path.join(skillsDir, 'eyeglass.md');
    if (fileExists(skillPath)) {
        log('Eyeglass skill already exists', 'success');
        return true;
    }
    if (dryRun) {
        log(`Would create ${path.relative(cwd, skillPath)}`);
    }
    else {
        if (!fileExists(skillsDir)) {
            fs.mkdirSync(skillsDir, { recursive: true });
        }
        writeFile(skillPath, EYEGLASS_SKILL);
        log('Created .claude/skills/eyeglass.md', 'success');
    }
    return true;
}
function setupClaudeConfig(dryRun) {
    const cwd = process.cwd();
    const claudeDir = path.join(cwd, '.claude');
    const configPath = path.join(claudeDir, 'settings.json');
    if (fileExists(configPath)) {
        // Check if eyeglass is already configured
        try {
            const existing = JSON.parse(readFile(configPath));
            if (existing.mcpServers?.eyeglass) {
                log('Claude Code MCP config already exists', 'success');
                return true;
            }
            // Merge with existing config
            const merged = {
                ...existing,
                mcpServers: {
                    ...existing.mcpServers,
                    ...CLAUDE_CONFIG.mcpServers,
                },
            };
            if (dryRun) {
                log(`Would update ${configPath} with eyeglass MCP config`);
            }
            else {
                writeFile(configPath, JSON.stringify(merged, null, 2));
                log('Added eyeglass to existing Claude Code config', 'success');
            }
            return true;
        }
        catch {
            log('Could not parse existing .claude/settings.json', 'warn');
            return false;
        }
    }
    if (dryRun) {
        log(`Would create ${configPath}`);
    }
    else {
        if (!fileExists(claudeDir)) {
            fs.mkdirSync(claudeDir, { recursive: true });
        }
        writeFile(configPath, JSON.stringify(CLAUDE_CONFIG, null, 2));
        log('Created .claude/settings.json with MCP server config', 'success');
    }
    return true;
}
function setupCopilotConfig(dryRun) {
    const cwd = process.cwd();
    const copilotDir = path.join(cwd, '.copilot');
    const configPath = path.join(copilotDir, 'mcp-config.json');
    if (fileExists(configPath)) {
        try {
            const existing = JSON.parse(readFile(configPath));
            if (existing.mcpServers?.eyeglass) {
                log('Copilot CLI MCP config already exists', 'success');
                return true;
            }
            // Merge with existing config
            const merged = {
                ...existing,
                mcpServers: {
                    ...existing.mcpServers,
                    ...COPILOT_MCP_CONFIG.mcpServers,
                },
            };
            if (dryRun) {
                log('Would update .copilot/mcp-config.json with eyeglass MCP config');
            }
            else {
                writeFile(configPath, JSON.stringify(merged, null, 2));
                log('Added eyeglass to existing Copilot CLI MCP config', 'success');
            }
            return true;
        }
        catch {
            log('Could not parse existing .copilot/mcp-config.json', 'warn');
            return false;
        }
    }
    if (dryRun) {
        log(`Would create ${configPath}`);
    }
    else {
        if (!fileExists(copilotDir)) {
            fs.mkdirSync(copilotDir, { recursive: true });
        }
        writeFile(configPath, JSON.stringify(COPILOT_MCP_CONFIG, null, 2));
        log('Created .copilot/mcp-config.json for GitHub Copilot CLI', 'success');
    }
    return true;
}
function setupCodexConfig(dryRun) {
    const cwd = process.cwd();
    const codexDir = path.join(cwd, '.codex');
    const configPath = path.join(codexDir, 'eyeglass.md');
    const codexInstructions = `# Eyeglass Integration for Codex CLI

Eyeglass provides HTTP endpoints for interacting with UI elements selected in the browser.

## Base URL
\`${CODEX_BASE_URL}\`

## Endpoints

### Wait for Request (blocking)
\`\`\`
GET /api/wait?timeout=300000
\`\`\`
Blocks until user selects an element. Returns markdown with element context.

### Get Current Focus
\`\`\`
GET /api/focus
\`\`\`
Returns the currently focused element as markdown.

### Update Status
\`\`\`
POST /api/status
Content-Type: application/json

{"status": "fixing", "message": "Working on it..."}
\`\`\`
Status values: \`idle\`, \`pending\`, \`fixing\`, \`success\`, \`failed\`

### Report Action
\`\`\`
POST /api/action
Content-Type: application/json

{"action": "reading", "target": "src/components/Button.tsx"}
\`\`\`
Actions: \`reading\`, \`writing\`, \`searching\`, \`thinking\`

### Send Thought
\`\`\`
POST /api/thought
Content-Type: application/json

{"content": "I think we should use a CSS variable for this color..."}
\`\`\`

### Get History
\`\`\`
GET /api/history
\`\`\`
Returns up to 5 previous focus requests.

## Workflow

1. Start the bridge: \`npx eyeglass-bridge\`
2. Call \`GET /api/wait\` to block until user selects an element
3. Make your changes based on the returned context
4. Call \`POST /api/status\` with \`{"status": "success", "message": "Done!"}\`
5. Loop back to step 2
`;
    if (fileExists(configPath)) {
        log('Codex eyeglass instructions already exist', 'success');
        return true;
    }
    if (dryRun) {
        log(`Would create ${configPath}`);
    }
    else {
        if (!fileExists(codexDir)) {
            fs.mkdirSync(codexDir, { recursive: true });
        }
        writeFile(configPath, codexInstructions);
        log('Created .codex/eyeglass.md with HTTP API instructions', 'success');
    }
    return true;
}
function setupVite(configFile, dryRun) {
    const cwd = process.cwd();
    // Find entry file (main.tsx, main.ts, main.jsx, main.js, src/main.*, etc.)
    const entryFiles = [
        'src/main.tsx',
        'src/main.ts',
        'src/main.jsx',
        'src/main.js',
        'main.tsx',
        'main.ts',
        'main.jsx',
        'main.js',
    ];
    let entryFile = null;
    for (const entry of entryFiles) {
        const fullPath = path.join(cwd, entry);
        if (fileExists(fullPath)) {
            entryFile = fullPath;
            break;
        }
    }
    // Fallback: parse index.html to find the actual entry script
    if (!entryFile) {
        entryFile = findEntryFromHtml(cwd);
        if (entryFile) {
            log(`Found entry file from index.html: ${path.relative(cwd, entryFile)}`, 'info');
        }
    }
    if (!entryFile) {
        log('Could not find entry file - please import @eyeglass/inspector manually in your main file', 'warn');
        log('Tip: Check your index.html for the entry script path', 'info');
        return false;
    }
    const content = readFile(entryFile);
    // Check if already imported
    if (content.includes('@eyeglass/inspector')) {
        log('Inspector already imported', 'success');
        return true;
    }
    // Add import at the top
    const importStatement = `import '@eyeglass/inspector';\n`;
    const newContent = importStatement + content;
    if (dryRun) {
        log(`Would add inspector import to ${path.relative(cwd, entryFile)}`);
    }
    else {
        writeFile(entryFile, newContent);
        log(`Added inspector import to ${path.relative(cwd, entryFile)}`, 'success');
    }
    return true;
}
function setupNext(configFile, dryRun) {
    const cwd = process.cwd();
    // Check for App Router (app/ directory) vs Pages Router (pages/ directory)
    const isAppRouter = fileExists(path.join(cwd, 'app')) || fileExists(path.join(cwd, 'src/app'));
    if (isAppRouter) {
        return setupNextAppRouter(cwd, dryRun);
    }
    else {
        return setupNextPagesRouter(cwd, dryRun);
    }
}
function setupNextAppRouter(cwd, dryRun) {
    // For App Router, we need a client component wrapper since layout.tsx is a server component
    const appDirs = ['app', 'src/app'];
    let appDir = null;
    for (const dir of appDirs) {
        if (fileExists(path.join(cwd, dir))) {
            appDir = path.join(cwd, dir);
            break;
        }
    }
    if (!appDir) {
        log('Could not find app/ directory', 'warn');
        return false;
    }
    // Create the client component wrapper
    const providerPath = path.join(appDir, 'eyeglass-provider.tsx');
    const providerContent = `'use client';

import { useEffect } from 'react';

export function EyeglassProvider({ children }: { children: React.ReactNode }) {
  useEffect(() => {
    import('@eyeglass/inspector');
  }, []);

  return <>{children}</>;
}
`;
    if (fileExists(providerPath)) {
        log('Eyeglass provider already exists', 'success');
    }
    else {
        if (dryRun) {
            log(`Would create ${path.relative(cwd, providerPath)}`);
        }
        else {
            writeFile(providerPath, providerContent);
            log(`Created ${path.relative(cwd, providerPath)}`, 'success');
        }
    }
    // Find and update layout.tsx to include the provider
    const layoutFiles = ['layout.tsx', 'layout.jsx'];
    let layoutPath = null;
    for (const file of layoutFiles) {
        const fullPath = path.join(appDir, file);
        if (fileExists(fullPath)) {
            layoutPath = fullPath;
            break;
        }
    }
    if (!layoutPath) {
        log('Could not find app/layout.tsx - please add <EyeglassProvider> manually', 'warn');
        log('Import: import { EyeglassProvider } from "./eyeglass-provider"', 'info');
        log('Wrap your {children} with <EyeglassProvider>{children}</EyeglassProvider>', 'info');
        return false;
    }
    const layoutContent = readFile(layoutPath);
    // Check if already configured
    if (layoutContent.includes('EyeglassProvider') || layoutContent.includes('@eyeglass/inspector')) {
        log('Layout already has Eyeglass configured', 'success');
        return true;
    }
    // Add import and wrap children with provider
    const importStatement = `import { EyeglassProvider } from './eyeglass-provider';\n`;
    // Find where to add import (after any existing imports or 'use client')
    let newContent = layoutContent;
    // Add import at the top
    if (newContent.startsWith("'use client'") || newContent.startsWith('"use client"')) {
        const firstLineEnd = newContent.indexOf('\n') + 1;
        newContent = newContent.slice(0, firstLineEnd) + importStatement + newContent.slice(firstLineEnd);
    }
    else {
        newContent = importStatement + newContent;
    }
    // Wrap {children} with <EyeglassProvider>
    // Look for patterns like: {children} or { children }
    newContent = newContent.replace(/(\{[\s]*children[\s]*\})/g, '<EyeglassProvider>$1</EyeglassProvider>');
    if (dryRun) {
        log(`Would update ${path.relative(cwd, layoutPath)} to include EyeglassProvider`);
    }
    else {
        writeFile(layoutPath, newContent);
        log(`Updated ${path.relative(cwd, layoutPath)} with EyeglassProvider`, 'success');
    }
    return true;
}
function setupNextPagesRouter(cwd, dryRun) {
    // For Pages Router, we can import directly in _app.tsx
    const appFiles = [
        'pages/_app.tsx',
        'pages/_app.jsx',
        'src/pages/_app.tsx',
        'src/pages/_app.jsx',
    ];
    let targetFile = null;
    for (const file of appFiles) {
        const fullPath = path.join(cwd, file);
        if (fileExists(fullPath)) {
            targetFile = fullPath;
            break;
        }
    }
    if (!targetFile) {
        log('Could not find pages/_app.tsx - please import @eyeglass/inspector manually', 'warn');
        return false;
    }
    const fileContent = readFile(targetFile);
    // Check if already imported
    if (fileContent.includes('@eyeglass/inspector')) {
        log('Inspector already imported in ' + path.basename(targetFile), 'success');
        return true;
    }
    // Add import at the top
    const importStatement = `import '@eyeglass/inspector';\n`;
    const newContent = importStatement + fileContent;
    if (dryRun) {
        log(`Would add inspector import to ${path.relative(cwd, targetFile)}`);
    }
    else {
        writeFile(targetFile, newContent);
        log(`Added inspector import to ${path.relative(cwd, targetFile)}`, 'success');
    }
    return true;
}
function setupCRA(entryFile, dryRun) {
    const cwd = process.cwd();
    // Find entry file if not provided
    if (!entryFile) {
        const entryFiles = ['src/index.tsx', 'src/index.ts', 'src/index.jsx', 'src/index.js'];
        for (const entry of entryFiles) {
            const fullPath = path.join(cwd, entry);
            if (fileExists(fullPath)) {
                entryFile = fullPath;
                break;
            }
        }
    }
    // Fallback: parse index.html to find the actual entry script
    if (!entryFile) {
        entryFile = findEntryFromHtml(cwd) ?? undefined;
        if (entryFile) {
            log(`Found entry file from index.html: ${path.relative(cwd, entryFile)}`, 'info');
        }
    }
    if (!entryFile || !fileExists(entryFile)) {
        log('Could not find entry file - please import @eyeglass/inspector manually', 'warn');
        log('Tip: Check your index.html for the entry script path', 'info');
        return false;
    }
    const content = readFile(entryFile);
    // Check if already imported
    if (content.includes('@eyeglass/inspector')) {
        log('Inspector already imported', 'success');
        return true;
    }
    // Add import at the top
    const importStatement = `import '@eyeglass/inspector';\n`;
    const newContent = importStatement + content;
    if (dryRun) {
        log(`Would add inspector import to ${path.relative(cwd, entryFile)}`);
    }
    else {
        writeFile(entryFile, newContent);
        log(`Added inspector import to ${path.relative(cwd, entryFile)}`, 'success');
    }
    return true;
}
async function init(options) {
    const { dryRun, skipInstall } = options;
    let { agents } = options;
    console.log(LOGO);
    if (dryRun) {
        log('Running in dry-run mode - no changes will be made\n', 'warn');
    }
    // Prompt for agent selection if not provided
    if (!agents || agents.length === 0) {
        agents = await promptAgentSelection();
    }
    const agentNames = agents.map((a) => {
        switch (a) {
            case 'claude': return 'Claude Code';
            case 'copilot': return 'GitHub Copilot CLI';
            case 'codex': return 'OpenAI Codex CLI';
        }
    });
    log(`Configuring for: ${agentNames.join(', ')}\n`);
    // Detect project
    const project = detectProject();
    log(`Detected: ${project.type}${project.typescript ? ' (TypeScript)' : ''}`);
    // Step 1: Install inspector
    if (!skipInstall) {
        if (dryRun) {
            log('Would install @eyeglass/inspector');
        }
        else {
            const installed = installPackage('@eyeglass/inspector', true);
            if (installed) {
                log('Installed @eyeglass/inspector', 'success');
            }
            else {
                log('Failed to install @eyeglass/inspector - please install manually', 'error');
            }
        }
    }
    // Step 2: Setup agent-specific configs
    console.log('');
    for (const agent of agents) {
        switch (agent) {
            case 'claude':
                setupClaudeConfig(dryRun);
                setupEyeglassSkill(dryRun);
                break;
            case 'copilot':
                setupCopilotConfig(dryRun);
                break;
            case 'codex':
                setupCodexConfig(dryRun);
                break;
        }
    }
    // Step 4: Setup project-specific integration
    console.log('');
    switch (project.type) {
        case 'vite':
            if (project.configFile) {
                setupVite(project.configFile, dryRun);
            }
            break;
        case 'next':
            if (project.configFile) {
                setupNext(project.configFile, dryRun);
            }
            break;
        case 'cra':
        case 'remix':
            setupCRA(project.entryFile, dryRun);
            break;
        default: {
            // Try to find entry file from index.html for unknown project types
            const entryFromHtml = findEntryFromHtml(process.cwd());
            if (entryFromHtml) {
                log(`Found entry file from index.html: ${path.relative(process.cwd(), entryFromHtml)}`, 'info');
                const content = readFile(entryFromHtml);
                if (content.includes('@eyeglass/inspector')) {
                    log('Inspector already imported', 'success');
                }
                else {
                    const importStatement = `import '@eyeglass/inspector';\n`;
                    const newContent = importStatement + content;
                    if (dryRun) {
                        log(`Would add inspector import to ${path.relative(process.cwd(), entryFromHtml)}`);
                    }
                    else {
                        writeFile(entryFromHtml, newContent);
                        log(`Added inspector import to ${path.relative(process.cwd(), entryFromHtml)}`, 'success');
                    }
                }
            }
            else {
                log('Unknown project type - please configure manually:', 'warn');
                console.log('  1. Import @eyeglass/inspector in your entry file');
                console.log('  2. Or add <script type="module">import "@eyeglass/inspector";</script> to your HTML\n');
            }
            break;
        }
    }
    // Done!
    console.log('\n\x1b[1mSetup complete!\x1b[0m\n');
    printUsageInstructions(agents);
}
function printUsageInstructions(agents) {
    console.log('\x1b[1mHow to use Eyeglass:\x1b[0m\n');
    console.log('  1. Start your dev server');
    console.log('  2. Start the Eyeglass bridge: \x1b[36mnpx eyeglass-bridge\x1b[0m');
    console.log('');
    if (agents.includes('claude')) {
        console.log('  \x1b[1mClaude Code:\x1b[0m');
        console.log('    - Run \x1b[36mclaude\x1b[0m in this directory');
        console.log('    - Say \x1b[36m"watch eyeglass"\x1b[0m or \x1b[36m"/eyeglass"\x1b[0m');
        console.log('');
    }
    if (agents.includes('copilot')) {
        console.log('  \x1b[1mGitHub Copilot CLI:\x1b[0m');
        console.log('    - Run \x1b[36mgh copilot\x1b[0m in this directory');
        console.log('    - Copilot will auto-connect to the eyeglass MCP server');
        console.log('');
    }
    if (agents.includes('codex')) {
        console.log('  \x1b[1mOpenAI Codex CLI:\x1b[0m');
        console.log('    - See \x1b[36m.codex/eyeglass.md\x1b[0m for HTTP API docs');
        console.log('    - Use \x1b[36mGET http://localhost:3300/api/wait\x1b[0m to listen');
        console.log('');
    }
    console.log('  3. In your browser, hover over any element and click to select');
    console.log('  4. Type your request (e.g., "make this blue") and submit');
    console.log('     → Your agent automatically receives it and starts working!\n');
    console.log('\x1b[2mTip: You never need to leave your browser - your agent watches for requests.\x1b[0m\n');
}
function help() {
    console.log(LOGO);
    console.log(`\x1b[2mVisual debugging for AI coding agents\x1b[0m

Point at UI elements in your browser and tell your AI agent what to change.
Works with Claude Code, GitHub Copilot CLI, and OpenAI Codex CLI.

\x1b[1mUSAGE\x1b[0m
  npx @eyeglass/cli <command> [options]

\x1b[1mCOMMANDS\x1b[0m
  init          Initialize Eyeglass in your project (interactive)
  help          Show this help message

\x1b[1mOPTIONS\x1b[0m
  --dry-run       Preview changes without making them
  --skip-install  Skip installing @eyeglass/inspector
  --claude        Configure for Claude Code (stdio MCP)
  --copilot       Configure for GitHub Copilot CLI (local MCP)
  --codex         Configure for OpenAI Codex CLI (HTTP API)

\x1b[1mEXAMPLES\x1b[0m
  npx @eyeglass/cli init              # Interactive agent selection
  npx @eyeglass/cli init --claude     # Setup for Claude Code only
  npx @eyeglass/cli init --copilot --codex  # Setup for multiple agents
  npx @eyeglass/cli init --dry-run    # Preview what would change

\x1b[1mSUPPORTED AGENTS\x1b[0m
  Claude Code      - Uses stdio MCP (.claude/settings.json)
  GitHub Copilot CLI - Uses local MCP (.copilot/mcp-config.json)
  OpenAI Codex     - Uses HTTP API (.codex/eyeglass.md)

\x1b[1mWORKFLOW\x1b[0m
  1. Run \x1b[36mnpx @eyeglass/cli init\x1b[0m in your project
  2. Start your dev server
  3. Start your AI coding agent
  4. In your browser: hover over element → click → type request
  5. Your agent automatically picks up requests and makes changes!

\x1b[1mMORE INFO\x1b[0m
  https://github.com/donutboyband/eyeglass
`);
}
// ============================================================================
// Main
// ============================================================================
const args = process.argv.slice(2);
const command = args.find((arg) => !arg.startsWith('-'));
const flags = args.filter((arg) => arg.startsWith('-'));
// Parse agent flags
const agentFlags = [];
if (flags.includes('--claude'))
    agentFlags.push('claude');
if (flags.includes('--copilot'))
    agentFlags.push('copilot');
if (flags.includes('--codex'))
    agentFlags.push('codex');
const options = {
    dryRun: flags.includes('--dry-run'),
    skipInstall: flags.includes('--skip-install'),
    agents: agentFlags.length > 0 ? agentFlags : undefined,
};
switch (command) {
    case 'init':
        init(options).catch((err) => {
            console.error('Error:', err.message);
            process.exit(1);
        });
        break;
    case 'help':
    case undefined:
        help();
        break;
    default:
        if (command) {
            console.error(`Unknown command: ${command}\n`);
        }
        help();
        process.exit(command ? 1 : 0);
}
